@page "/products"
@using GabsHybridApp.Shared.Data
@using GabsHybridApp.Shared.Models
@using Microsoft.EntityFrameworkCore
@inject IFormFactor FormFactor
@inject IDbContextFactory<HybridAppDbContext> DbFactory
@inject ProductSyncService ProductSync
@inject HttpClient Http

<PageTitle>Products</PageTitle>
<h1>Products</h1>

<MudTextField T="string" ValueChanged="@(s => OnSearch(s))" Placeholder="Search" Variant="Variant.Outlined" Adornment=" Adornment.Start"
              AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0" Clearable="true"></MudTextField>

<MudSimpleTable Hover="true" Class="products-css mb-5" Style="overflow-x: auto;">
    <thead>
        <tr>
            <th>Id</th>
            <th>Name</th>
            <th class="text-right">Price</th>
            <th>Unit</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var productRow in products)
        {
            <tr>
                <td>@productRow.Id</td>
                <td>@productRow.Name</td>
                <td class="text-right">@productRow.UnitPrice</td>
                <td>@productRow.Unit</td>
            </tr>
        }
    </tbody>
</MudSimpleTable>

@code {
    List<Product> products = new();
    Product product = new();
    string strSearch = string.Empty;

    bool IsWeb => string.Equals(FormFactor.GetFormFactor(), "Web", StringComparison.OrdinalIgnoreCase);

    private void LoadProducts()
    {
        var _db = DbFactory.CreateDbContext();  
        if (!string.IsNullOrEmpty(strSearch))
            products = _db.Products.Where(x => x.Name!.ToLower().Contains(strSearch.ToLower())).ToList();
        else
            products = _db.Products.ToList();
    }

    protected override async Task OnInitializedAsync()
    {
        LoadProducts();
        if (!IsWeb)
        {
            await SyncNow();
        }           
    }

    private void OnSearch(string text)
    {
        strSearch = text;
        LoadProducts();
    }

    bool _syncing;
    private async Task SyncNow()
    {
        if (_syncing) return;
        _syncing = true;

        try
        {
            // Keep the operation bounded so we never hang the UI
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));

            // Swallows its own network errors and returns 0 on failure
            await ProductSync.SyncAsync("admin", cts.Token);
        }
        catch (OperationCanceledException)
        {
            // Optional: show a non-blocking toast/snackbar like "Sync timed out"
        }
        catch (Exception)
        {
            // Optional: show a non-blocking toast/snackbar like "Sync failed"
            // Don't rethrow—just log if you have logging
        }
        finally
        {
            _syncing = false;

            // Always refresh local view; even if sync failed, this won’t crash
            LoadProducts();
            StateHasChanged();
        }
    }

}
